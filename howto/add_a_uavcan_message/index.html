<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>How to handle a new UAVCAN message type? - CVRA Robot Software</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.1.2, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../css/style.min.css" rel="stylesheet">
<link href="../../ytvideo.css" rel="stylesheet">
<link href="../../styles.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">

<nav role="navigation">
<ul class="summary">
<li>
<a href="../.." target="_blank" class="custom-link">CVRA Robot Software</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../..">Home</a>
<li class="header">Robot architecture</li>

<li>
<a href="../../architecture/hardware2020/" class="">2020 hardware architecture</a>
</li>

<li>
<a href="../../architecture/life-of-a-motion/" class="">Life of a motion</a>
</li>

<li>
<a href="../../design/linux-master/" class="">Master firmware on Linux</a>
</li>

<li class="header">How to</li>

<li>
<a href="../calibrate-odometry/" class="">Calibrate the odometry</a>
</li>

<li>
<a href="./" class="active">How to handle a new UAVCAN message type?</a>
</li>

<li class="header">Systems</li>

<li>
<a href="../../can/positioning/" class="">Positioning system</a>
</li>

<li class="header">CAN</li>

<li>
<a href="../../can/intro/" class="">CAN Ecosystem</a>
</li>

<li>
<a href="../../can/motor/" class="">Motor board</a>
</li>

<li>
<a href="../../can/io/" class="">IO board</a>
</li>

<li>
<a href="../../can/sensor/" class="">Sensor board</a>
</li>

<li>
<a href="../../can/beacon/" class="">Beacon board</a>
</li>

<li>
<a href="../../can/adapter/" class="">CAN USB adapter</a>
</li>

<li>
<a href="../../can/bootloader/" class="">CAN bootloader</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">

<section class="normal markdown-section">



<h1 id="how-to-handle-a-new-uavcan-message-type">How to handle a new UAVCAN message type?</h1>
<p>Things you will need for this tutorial:</p>
<ul>
<li>A working arm-none-eabi compiler setup</li>
<li>A can-io board</li>
<li>A CAN cable</li>
<li>A CVRA USB dongle</li>
<li>two 120 Ohm resistors</li>
</ul>
<p>The goal of this tutorial is the classical "Hello World" in embedded sytems: blinking a LED.
However, we want this to happen through CAN, in order to learn how to implement new services.</p>
<h2 id="disabling-the-automatic-led-blinking">Disabling the automatic LED blinking</h2>
<p>Go to the <code>can-io-firmware</code>, and edit <code>main.c</code> to disable the blinker thread:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">halInit</span><span class="p">();</span>
    <span class="n">chSysInit</span><span class="p">();</span>

    <span class="n">debug_init</span><span class="p">();</span>
    <span class="n">NOTICE</span><span class="p">(</span><span class="s">&quot;boot&quot;</span><span class="p">);</span>

    <span class="c1">// comment the following line</span>
    <span class="c1">// blinker_start();</span>
</code></pre></div>

<p>Then, rebuild the new firmware for the CAN IO board, by running the following commands:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">cd</span> can-io-firmware/
packager
make dsdlc
make <span class="nv">USE_BOOTLOADER</span><span class="o">=</span>yes
</code></pre></div>

<p>We can now power the bus through USB, and to flash the board:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Note that the path to the serial port (/dev/...) changes from computer</span>
<span class="c1"># to computer.</span>
can_dongle_power /dev/tty.usbmodem3031 on

<span class="c1"># Check that the board is detected</span>
bootloader_read_config --all /dev/tty.usbmodem3031
</code></pre></div>

<p>You should get the following output.
If you get an error you can retry, as it can get stuck.</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;ID&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nt">&quot;application_crc&quot;</span><span class="p">:</span> <span class="mi">1298708532</span><span class="p">,</span>
        <span class="nt">&quot;application_size&quot;</span><span class="p">:</span> <span class="mi">44808</span><span class="p">,</span>
        <span class="nt">&quot;device_class&quot;</span><span class="p">:</span> <span class="s2">&quot;can-io-board&quot;</span><span class="p">,</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;foobar2000&quot;</span><span class="p">,</span>
        <span class="nt">&quot;update_count&quot;</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This is the configuration of the bootloader for this board.
It is not erased when reflashing and can be read from the application.</p>
<ul>
<li><strong>ID</strong> is the address of the board, which must be unique on the bus and must be between and 127.</li>
<li><strong>application_crc</strong> and <strong>application_size</strong> are used by the bootloader to detect if the firmware is corrupted, for example missing parts of the firmware.</li>
<li><strong>device_class</strong> is the name of the hardware model, and is used to check if we are flashing new code on the correct board, to avoid damage.</li>
<li><strong>name</strong> is a human readable name for this board, to help diagnose which board we are talking to (<code>left-wheel</code> is way easier to guess 42). For now it is set to the default, <code>foobar2000</code>.</li>
<li>Finally, <strong>update_count</strong> is the number of times a new firmware was flashed by the bootloader, we use it to find if there are issues with old boards.</li>
</ul>
<p>Now that we know the ID of our board we can flash it with our fresh firmware:</p>
<div class="codehilite"><pre><span></span><code>bootloader_flash --port /dev/tty.usbmodem3031 <span class="se">\</span>
    --binary build/ch.bin <span class="se">\</span>
    --base-address 0x08003800 <span class="se">\</span>
    --device-class can-io-board <span class="se">\</span>
    --run <span class="se">\</span>
    <span class="m">1</span>
</code></pre></div>

<p>As you can see the bootloader requires a few flags to flash the board.
Fortunately most of them do not change very often, or are easy to find.</p>
<ul>
<li><code>--port</code> is the name of the serial port on which the CAN dongle is connected.</li>
<li><code>--binary</code> is the path to the binary we want to flash.</li>
<li><code>--base-address</code> is the address of the beginning of the application memory.
    You can find it in the linker script <a href="https://github.com/cvra/robot-software/blob/master/can-io-firmware/linker/STM32F302x8_bootloader.ld#L8"><code>can-io-firmware/linker/STM32F302x8_bootloader.ld</code></a>, look for <code>flash0</code>.</li>
<li><code>--device-class</code> must match the one stored in the config.</li>
<li><code>--run</code> asks the board to run the application once the firmware upload is done.</li>
</ul>
<p>Finally, we put the list of board IDs to update (just <code>1</code> here).</p>
<p>You should get a progress bar, with <code>Verifying firmware... OK</code> at the end.
Your application will start and the LED should be off.</p>
<h2 id="defining-a-new-uavcan-message-type">Defining a new UAVCAN message type</h2>
<p>We will create new message type that will be used to ask the board to turn the LED on or off.
Create a new file in <code>uavcan_data_types/cvra/io/200.LEDCommand.uavcan</code> with the following content.
This defines a <strong>service</strong>, which is made of a request and a response.
The request here contains just a single boolean, to indicate the desired LED state and the response a single integer for demo purpose.</p>
<div class="codehilite"><pre><span></span><code>bool led_status
---
int32 data
</code></pre></div>

<p>Now we must run <code>make dsdlc</code> again.
This will generate the C++ code required to serialize and interpret our new message type.</p>
<h2 id="handling-the-new-message-type-in-our-application">Handling the new message type in our application</h2>
<p>Create a new C++ file <code>can-io-firmware/src/uavcan/LEDCommand_handler.cpp</code> with the following content</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* For accessing the GPIO functions */</span>
<span class="cp">#include</span> <span class="cpf">&lt;hal.h&gt;</span><span class="cp"></span>

<span class="cm">/* UAVCAN interface */</span>
<span class="cp">#include</span> <span class="cpf">&lt;uavcan/uavcan.hpp&gt;</span><span class="cp"></span>

<span class="cm">/* Code generated from our .uavcan file */</span>
<span class="cp">#include</span> <span class="cpf">&lt;cvra/io/LEDCommand.hpp&gt;</span><span class="cp"></span>

<span class="cm">/* This function is called every time we receive a request for our newly</span>
<span class="cm"> * defined LedCommand service.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">LEDCommand_handler</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ReceivedDataStructure</span><span class="o">&lt;</span><span class="n">cvra</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">LEDCommand</span><span class="o">::</span><span class="n">Request</span><span class="o">&gt;&amp;</span> <span class="n">req</span><span class="p">,</span>
    <span class="n">cvra</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">LEDCommand</span><span class="o">::</span><span class="n">Response</span><span class="o">&amp;</span> <span class="n">rsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*  req contains the incoming data, while rsp will be sent back as a reply</span>
<span class="cm">     *  to this request. */</span>

    <span class="cm">/* Set the LED status to the requested value */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">led_status</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">palSetPad</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span> <span class="n">GPIOA_LED</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">palClearPad</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span> <span class="n">GPIOA_LED</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Reply with an example data. */</span>
    <span class="n">rsp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Also create the associated header, <code>can-io-firmware/src/uavcan/LEDCommand_handler.hpp</code>.
In this file we will put the prototype of our handler:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;uavcan/uavcan.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cvra/io/LEDCommand.hpp&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">LEDCommand_handler</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">uavcan</span><span class="o">::</span><span class="n">ReceivedDataStructure</span><span class="o">&lt;</span><span class="n">cvra</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">LEDCommand</span><span class="o">::</span><span class="n">Request</span><span class="o">&gt;&amp;</span> <span class="n">req</span><span class="p">,</span>
    <span class="n">cvra</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">LEDCommand</span><span class="o">::</span><span class="n">Response</span> <span class="o">&amp;</span><span class="n">rsp</span><span class="p">);</span>
</code></pre></div>

<p>We can then add this new file to the build system, in <code>can-io-firmware/package.yml</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># [...]</span>
<span class="nt">target.arm</span><span class="p">:</span>
<span class="c1"># [...]</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">src/uavcan/ServoPWM_handler.cpp</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">src/uavcan/DigitalInput_pub.cpp</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">src/uavcan/LEDCommand_handler.cpp</span> <span class="c1"># add this line</span>
<span class="c1"># [...]</span>
</code></pre></div>

<p>Now you can regenerate the Makefiles (<code>packager</code>) and rebuild the binary:</p>
<div class="codehilite"><pre><span></span><code>packager
make <span class="nv">USE_BOOTLOADER</span><span class="o">=</span>yes
</code></pre></div>

<p>Finally, reflash it.
You can use the same command as before, but you need to power cycle the board first, to put it back in bootloader mode.</p>
<h2 id="driving-our-led-from-python">Driving our LED from Python</h2>
<p>Now it is time to drive our LED from our computer, using a simple Python script.
Put the following in <code>can-io-firmware/blink.py</code>.
You can run it by running <code>cd can-io-firmware &amp;&amp; python blink.py</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">uavcan</span>

<span class="c1"># Reads our new custom message definition</span>
<span class="n">uavcan</span><span class="o">.</span><span class="n">load_dsdl</span><span class="p">(</span><span class="s2">&quot;../uavcan_data_types/cvra&quot;</span><span class="p">)</span>

<span class="c1"># Creates a UAVCAN device with address 123.</span>
<span class="c1"># As before, you might have to change the serial port to which your CAN adapter</span>
<span class="c1"># is connected.</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">uavcan</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;/dev/tty.usbmodem3031&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="n">BOARD_ID</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">led_status</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># This function is called every time we receive a response from the board, it</span>
<span class="c1"># simply prints the data we get back</span>
<span class="k">def</span> <span class="nf">led_command_reply_received</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reponse data&quot;</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>


<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Process UAVCAN messages for 1 second, then returns.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">spin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Sends a request to set the LED status to our target board.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">request</span><span class="p">(</span>
            <span class="n">uavcan</span><span class="o">.</span><span class="n">thirdparty</span><span class="o">.</span><span class="n">cvra</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">LEDCommand</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">led_status</span><span class="o">=</span><span class="n">led_status</span><span class="p">),</span>
            <span class="n">BOARD_ID</span><span class="p">,</span>
            <span class="n">led_command_reply_received</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Finally, invert the LED state so that it changes once a second.</span>
        <span class="n">led_status</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">led_status</span>
    <span class="k">except</span> <span class="n">uavcan</span><span class="o">.</span><span class="n">UAVCANException</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node error:&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
</code></pre></div>

<h2 id="conclusion">Conclusion</h2>
<p>In this tutorial, we saw how to define and use a custom message type for a new application.
We saw how this integrate in CVRA's tools (bootloader and build system).</p>
<p>The code for this tutorial is on <a href="https://github.com/cvra/robot-software/tree/uavcan-tutorial">Github</a>.
You can find more UAVCAN tutorials on their <a href="https://legacy.uavcan.org/">homepage</a>.</p>


</section>

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../js/main.js"></script>
<script src="../../js/gitbook.min.js"></script>
<script src="../../js/theme.min.js"></script>
</body>
</html>