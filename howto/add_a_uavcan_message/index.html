<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Handle new UAVCAN data types - CVRA Robot Software</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.2.3, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../css/style.min.css" rel="stylesheet">
<link href="../../ytvideo.css" rel="stylesheet">
<link href="../../styles.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">

<nav role="navigation">
<ul class="summary">
<li>
<a href="../.." target="_blank" class="custom-link">CVRA Robot Software</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../..">Home</a>
<li class="header">Robot architecture</li>

<li>
<a href="../../architecture/history/" class="">History & Design</a>
</li>

<li>
<a href="../../architecture/hardware2020/" class="">2020 hardware architecture</a>
</li>

<li>
<a href="../../architecture/life-of-a-motion/" class="">Life of a motion</a>
</li>

<li>
<a href="../../design/linux-master/" class="">Master firmware on Linux</a>
</li>

<li class="header">How to</li>

<li>
<a href="../calibrate-odometry/" class="">Calibrate the odometry</a>
</li>

<li>
<a href="./" class="active">Handle new UAVCAN data types</a>
</li>

<li>
<a href="../install_arm_gcc/" class="">Install the ARM compiler</a>
</li>

<li class="header">Systems</li>

<li>
<a href="../../can/positioning/" class="">Positioning system</a>
</li>

<li class="header">CAN</li>

<li>
<a href="../../can/intro/" class="">CAN Ecosystem</a>
</li>

<li>
<a href="../../can/motor/" class="">Motor board</a>
</li>

<li>
<a href="../../can/io/" class="">IO board</a>
</li>

<li>
<a href="../../can/sensor/" class="">Sensor board</a>
</li>

<li>
<a href="../../can/beacon/" class="">Beacon board</a>
</li>

<li>
<a href="../../can/adapter/" class="">CAN USB adapter</a>
</li>

<li>
<a href="../../can/bootloader/" class="">CAN bootloader</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">

<section class="normal markdown-section">



<h1 id="handle-new-uavcan-data-types">Handle new UAVCAN data types</h1>
<p>Things you will need for this tutorial:</p>
<ul>
<li>A <a href="../install_arm_gcc/">working arm-none-eabi compiler setup</a></li>
<li>A can-io board</li>
<li>A CAN cable</li>
<li>A CVRA USB dongle</li>
<li>two 120 Ohm resistors</li>
</ul>
<p>The goal of this tutorial is the classical "Hello World" in embedded sytems: blinking a LED.
However, we want this to happen through CAN, in order to learn how to implement new services.</p>
<h2 id="disabling-the-automatic-led-blinking">Disabling the automatic LED blinking</h2>
<p>Go to the <code>can-io-firmware</code>, and edit <code>main.c</code> to disable the blinker thread:</p>
<div class="codehilite"><pre><span></span><code>:::c++
int main(void)
{
    halInit();
    chSysInit();

    debug_init();
    NOTICE(&quot;boot&quot;);

    // comment the following line
    // blinker_start();
</code></pre></div>

<p>Then, rebuild the new firmware for the CAN IO board, by running the following commands:</p>
<div class="codehilite"><pre><span></span><code>:::bash
cd can-io-firmware/
packager
make dsdlc
make USE_BOOTLOADER=yes
</code></pre></div>

<p>We can now power the bus through USB, and to flash the board:</p>
<div class="codehilite"><pre><span></span><code>:::bash
# Note that the path to the serial port (/dev/...) changes from computer
# to computer.
can_dongle_power /dev/tty.usbmodem3031 on

# Check that the board is detected
bootloader_read_config --all /dev/tty.usbmodem3031
</code></pre></div>

<p>You should get the following output.
If you get an error you can retry, as it can get stuck.</p>
<div class="codehilite"><pre><span></span><code>:::json
{
    &quot;1&quot;: {
        &quot;ID&quot;: 1,
        &quot;application_crc&quot;: 1298708532,
        &quot;application_size&quot;: 44808,
        &quot;device_class&quot;: &quot;can-io-board&quot;,
        &quot;name&quot;: &quot;foobar2000&quot;,
        &quot;update_count&quot;: 2
    }
}
</code></pre></div>

<p>If you get a message "Permission Denied", it means your user does not have permissions to access serial ports.
You can confirm this by running the same command, but with <code>sudo</code> to become admin first (<code>sudo can_dongle_power /dev/tty.usbmodem3031 on</code>).
You will be asked for your admin password; nothing will be shown on the screen, its normal for <code>sudo</code>.
If it works, you can then give your user access to the serial ports by running <code>sudo usermod -a -G dialout $USER</code>, then rebooting (tested on Ubuntu).</p>
<p>This is the configuration of the bootloader for this board.
It is not erased when reflashing and can be read from the application.</p>
<ul>
<li><strong>ID</strong> is the address of the board, which must be unique on the bus and must be between and 127.</li>
<li><strong>application_crc</strong> and <strong>application_size</strong> are used by the bootloader to detect if the firmware is corrupted, for example missing parts of the firmware.</li>
<li><strong>device_class</strong> is the name of the hardware model, and is used to check if we are flashing new code on the correct board, to avoid damage.</li>
<li><strong>name</strong> is a human readable name for this board, to help diagnose which board we are talking to (<code>left-wheel</code> is way easier to guess 42). For now it is set to the default, <code>foobar2000</code>.</li>
<li>Finally, <strong>update_count</strong> is the number of times a new firmware was flashed by the bootloader, we use it to find if there are issues with old boards.</li>
</ul>
<p>Now that we know the ID of our board we can flash it with our fresh firmware:</p>
<div class="codehilite"><pre><span></span><code>:::bash
bootloader_flash --port /dev/tty.usbmodem3031 \
    --binary build/ch.bin \
    --base-address 0x08003800 \
    --device-class can-io-board \
    --run \
    1
</code></pre></div>

<p>As you can see the bootloader requires a few flags to flash the board.
Fortunately most of them do not change very often, or are easy to find.</p>
<ul>
<li><code>--port</code> is the name of the serial port on which the CAN dongle is connected.</li>
<li><code>--binary</code> is the path to the binary we want to flash.</li>
<li><code>--base-address</code> is the address of the beginning of the application memory.
    You can find it in the linker script <a href="https://github.com/cvra/robot-software/blob/master/can-io-firmware/linker/STM32F302x8_bootloader.ld#L8"><code>can-io-firmware/linker/STM32F302x8_bootloader.ld</code></a>, look for <code>flash0</code>.</li>
<li><code>--device-class</code> must match the one stored in the config.</li>
<li><code>--run</code> asks the board to run the application once the firmware upload is done.</li>
</ul>
<p>Finally, we put the list of board IDs to update (just <code>1</code> here).</p>
<p>You should get a progress bar, with <code>Verifying firmware... OK</code> at the end.
Your application will start and the LED should be off.</p>
<h2 id="defining-a-new-uavcan-message-type">Defining a new UAVCAN message type</h2>
<p>We will create new message type that will be used to ask the board to turn the LED on or off.
Create a new file in <code>uavcan_data_types/cvra/io/200.LEDCommand.uavcan</code> with the following content.
This defines a <strong>service</strong>, which is made of a request and a response.
The request here contains just a single boolean, to indicate the desired LED state and the response a single integer for demo purpose.</p>
<div class="codehilite"><pre><span></span><code>bool led_status
---
int32 data
</code></pre></div>

<p>Now we must run <code>make dsdlc</code> again.
This will generate the C++ code required to serialize and interpret our new message type.</p>
<h2 id="handling-the-new-message-type-in-our-application">Handling the new message type in our application</h2>
<p>Create a new C++ file <code>can-io-firmware/src/uavcan/LEDCommand_handler.cpp</code> with the following content</p>
<div class="codehilite"><pre><span></span><code>:::c++
/* For accessing the GPIO functions */
#include &lt;hal.h&gt;

/* UAVCAN interface */
#include &lt;uavcan/uavcan.hpp&gt;

/* Code generated from our .uavcan file */
#include &lt;cvra/io/LEDCommand.hpp&gt;

/* This function is called every time we receive a request for our newly
 * defined LedCommand service.
 */
void LEDCommand_handler(
    const uavcan::ReceivedDataStructure&lt;cvra::io::LEDCommand::Request&gt;&amp; req,
    cvra::io::LEDCommand::Response&amp; rsp)
{
    /*  req contains the incoming data, while rsp will be sent back as a reply
     *  to this request. */

    /* Set the LED status to the requested value */
    if (req.led_status) {
        palSetPad(GPIOA, GPIOA_LED);
    } else {
        palClearPad(GPIOA, GPIOA_LED);
    }

    /* Reply with an example data. */
    rsp.data = 42;
}
</code></pre></div>

<p>Also create the associated header, <code>can-io-firmware/src/uavcan/LEDCommand_handler.hpp</code>.
In this file we will put the prototype of our handler:</p>
<div class="codehilite"><pre><span></span><code>:::c++
#pragma once

#include &lt;uavcan/uavcan.hpp&gt;
#include &lt;cvra/io/LEDCommand.hpp&gt;

void LEDCommand_handler(
    const uavcan::ReceivedDataStructure&lt;cvra::io::LEDCommand::Request&gt;&amp; req,
    cvra::io::LEDCommand::Response &amp;rsp);
</code></pre></div>

<p>We can then add this new file to the build system, in <code>can-io-firmware/package.yml</code>:</p>
<div class="codehilite"><pre><span></span><code>:::yaml
# [...]
target.arm:
# [...]
  - src/uavcan/ServoPWM_handler.cpp
  - src/uavcan/DigitalInput_pub.cpp
  - src/uavcan/LEDCommand_handler.cpp # add this line
# [...]
</code></pre></div>

<p>Now you can regenerate the Makefiles (<code>packager</code>) and rebuild the binary:</p>
<div class="codehilite"><pre><span></span><code>:::bash
packager
make USE_BOOTLOADER=yes
</code></pre></div>

<p>Finally, reflash it.
You can use the same command as before, but you need to power cycle the board first, to put it back in bootloader mode.</p>
<h2 id="driving-our-led-from-python">Driving our LED from Python</h2>
<p>Now it is time to drive our LED from our computer, using a simple Python script.
Put the following in <code>can-io-firmware/blink.py</code>.
You can run it by running <code>cd can-io-firmware &amp;&amp; python blink.py</code>.</p>
<div class="codehilite"><pre><span></span><code>:::python
import uavcan

# Reads our new custom message definition
uavcan.load_dsdl(&quot;../uavcan_data_types/cvra&quot;)

# Creates a UAVCAN device with address 123.
# As before, you might have to change the serial port to which your CAN adapter
# is connected.
node = uavcan.make_node(&quot;/dev/tty.usbmodem3031&quot;, node_id=123)
BOARD_ID = 1

led_status = True

# This function is called every time we receive a response from the board, it
# simply prints the data we get back
def led_command_reply_received(event):
    print(&quot;reponse data&quot;, event.response.data)


while True:
    try:
        # Process UAVCAN messages for 1 second, then returns.
        node.spin(1)

        # Sends a request to set the LED status to our target board.
        node.request(
            uavcan.thirdparty.cvra.io.LEDCommand.Request(led_status=led_status),
            BOARD_ID,
            led_command_reply_received,
        )

        # Finally, invert the LED state so that it changes once a second.
        led_status = not led_status
    except uavcan.UAVCANException as ex:
        print(&quot;Node error:&quot;, ex)
</code></pre></div>

<h2 id="conclusion">Conclusion</h2>
<p>In this tutorial, we saw how to define and use a custom message type for a new application.
We saw how this integrate in CVRA's tools (bootloader and build system).</p>
<p>The code for this tutorial is on <a href="https://github.com/cvra/robot-software/tree/uavcan-tutorial">Github</a>.
You can find more UAVCAN tutorials on their <a href="https://legacy.uavcan.org/">homepage</a>.</p>


</section>

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../js/main.js"></script>
<script src="../../js/gitbook.min.js"></script>
<script src="../../js/theme.min.js"></script>
</body>
</html>